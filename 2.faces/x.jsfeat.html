<html>
<head>

<title>Face Detection</title>

<style>
body {
  align-items: center;
  display: flex;
  flex-direction: row;
  justify-content: center;
  margin: 0;
  padding: 0;
}

video {
  position: absolute;
  visibility: hidden;
}  
</style>

</head>
<body>

<!-- Document elements -->
<video width="640" height="480" preload autoplay loop muted></video>
<canvas width="640" height="480"></canvas>

<!-- Feature detection library -->
<script src="../lib/jsfeat-min.js"></script>
<script src="../lib/frontalface.js"></script>

<script>
class Faces {
  constructor() {
    // Element references    
    this.video = document.querySelector( 'video' );
    this.canvas = document.querySelector( 'canvas' );
    this.context = this.canvas.getContext( '2d' );
    this.context.strokeStyle = 'yellow';

    this.image = new jsfeat.matrix_t( this.canvas.width, this.canvas.height, jsfeat.U8_t | jsfeat.C1_t );
    this.edges = new jsfeat.matrix_t( this.canvas.width, this.canvas.height, jsfeat.U8_t | jsfeat.C1_t );
    this.sum = new Int32Array( ( this.canvas.width + 1 ) * ( this.canvas.height + 1 ) );
    this.square = new Int32Array( ( this.canvas.width + 1 ) * ( this.canvas.height + 1 ) );
    this.tilted = new Int32Array( ( this.canvas.width + 1 ) * ( this.canvas.height + 1 ) );
    this.canny = new Int32Array( ( this.canvas.width + 1 ) * ( this.canvas.height + 1 ) );
    this.classifier = jsfeat.haar.frontalface;
    this.scale = Math.min( Faces.WORK_SIZE / this.video.width, Faces.WORK_SIZE / this.video.height );

    navigator.mediaDevices.getUserMedia( {audio: false, video: true} )
    .then( ( stream ) => {
      this.video.srcObject = stream;
      this.video.play();
      this.detect();
    } ).catch( ( error ) => {
      console.log( error );
    } );        
  }

  detect() {
    this.context.drawImage( this.video, 0, 0, this.canvas.width, this.canvas.height );
    
    let pixels = this.context.getImageData( 0, 0, this.canvas.width, this.canvas.height );

    jsfeat.imgproc.grayscale( pixels.data, this.canvas.width, this.canvas.height, this.image );

    if( Faces.EQUALIZE ) {
      jsfeat.imgproc.equalize_histogram( this.image, this.image );
    }

    jsfeat.imgproc.compute_integral_image( this.image, this.sum, this.square, this.classifier.tilted ? this.tilted : null );

    if( Faces.USE_CANNY ) {
      jsfeat.imgproc.canny( this.image, this.edges, 10, 50 );
      jsfeat.imgproc.compute_integral_image( this.edges, this.canny, null, null );
    }

    jsfeat.haar.edges_density = Faces.EDGES_DENSITY;

    let rectangles = jsfeat.haar.detect_multi_scale( this.sum, this.square, this.tilted, Faces.USE_CANNY ? this.canny : null, this.image.cols, this.image.rows, this.classifier, Faces.SCALE_FACTOR, Faces.SCALE_MINIMUM );
    rectangles = jsfeat.haar.group_rectangles( rectangles, 1 );

    this.faces( this.context, rectangles, this.canvas.width / this.image.cols, 1 );

    requestAnimationFrame( () => { return this.detect(); } );     
  }

  faces( context, rectangles, scale, maximum ) {
    let on = rectangles.length;
                
    if( on && maximum ) {
      jsfeat.math.qsort( rectangles, 0, on - 1, ( a, b ) => { return ( b.confidence < a.confidence ); } );
    }
                
    let n = maximum || on;
    n = Math.min( n, on );

    let r = 0;       

    for( let i = 0; i < n; ++i ) {
      r = rectangles[i];
      this.context.strokeRect( ( r.x * scale ) | 0, ( r.y * scale ) | 0, ( r.width * scale ) | 0, ( r.height * scale ) | 0 );
    }    
  }
}

Faces.EDGES_DENSITY = 0.13;
Faces.EQUALIZE = true;
Faces.SCALE_FACTOR = 1.2;
Faces.SCALE_MINIMUM = 2;
Faces.USE_CANNY = false;
Faces.WORK_SIZE = 160;

let app = new Faces();

</script>

</body>
</html>
